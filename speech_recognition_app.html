<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³å£°æ–‡å­—èµ·ã“ã—ã‚¢ãƒ—ãƒª V1.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body { font-family: 'Inter', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .main-content { flex-grow: 1; }
        .right-panel { width: 25rem; }
        .text-area { min-height: 200px; height: 100%; resize: none; }
        .record-item.selected { border: 2px solid #3b82f6; }
        .dragging { opacity: 0.5; }
        .drag-over { border: 2px dashed #3b82f6; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <!-- ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ -->
    <div class="flex flex-grow overflow-hidden">
        <!-- å·¦ãƒ‘ãƒãƒ«ï¼šå±¥æ­´ -->
        <div id="left-panel" class="w-1/4 bg-gray-800 p-4 flex flex-col h-full overflow-y-auto">
            <h2 class="text-xl font-bold mb-4">è¨˜éŒ²å±¥æ­´</h2>
            <div class="flex mb-4">
                <button id="new-folder-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full">æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ</button>
            </div>
            <div id="records-list" class="flex-grow"></div>
            <div id="storage-usage" class="mt-4 text-sm text-gray-400"></div>
        </div>
        <!-- ä¸­å¤®ãƒ‘ãƒãƒ«ï¼šæ–‡å­—èµ·ã“ã—ã‚¨ãƒªã‚¢ -->
        <div id="center-panel" class="main-content bg-gray-900 p-6 flex flex-col h-full">
            <div id="main-controls" class="flex items-center justify-between mb-4">
                 <h1 class="text-2xl font-bold">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—</h1>
                 <div id="timer" class="text-2xl font-mono bg-gray-800 px-4 py-2 rounded">00:00:00</div>
            </div>
            <div class="flex space-x-4 mb-4">
                <button id="start-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-full transition duration-300 ease-in-out transform hover:scale-105">éŒ²éŸ³é–‹å§‹</button>
                <button id="stop-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full hidden transition duration-300 ease-in-out transform hover:scale-105">éŒ²éŸ³åœæ­¢</button>
            </div>
             <textarea id="transcript" class="w-full flex-grow bg-gray-800 p-4 rounded text-lg leading-relaxed border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="ã“ã“ã«æ–‡å­—èµ·ã“ã—çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>
            <div class="mt-4 flex space-x-4">
                <button id="save-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full" disabled>è¨˜éŒ²ã‚’ä¿å­˜</button>
                <input type="file" id="file-input" class="hidden" accept="audio/*">
                <button id="file-transcribe-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded w-full">ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ–‡å­—èµ·ã“ã—</button>
            </div>
        </div>
        <!-- å³ãƒ‘ãƒãƒ«ï¼šè©³ç´°ãƒ»å†ç”Ÿ -->
        <div id="right-panel" class="right-panel bg-gray-800 p-6 flex-col h-full overflow-y-auto hidden">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">è©³ç´°</h2>
                <button id="close-right-panel" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="record-details">
                <h3 id="record-title" class="text-lg font-semibold mb-2"></h3>
                <p id="record-date" class="text-sm text-gray-400 mb-4"></p>
                <audio id="audio-player" controls class="w-full mb-4"></audio>
                <textarea id="record-text" class="w-full h-64 bg-gray-700 p-2 rounded"></textarea>
                 <div class="mt-4 flex space-x-2">
                     <button id="summarize-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded w-full">è¦ç´„ã‚’é–‹å§‹</button>
                     <button id="update-record-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">å¤‰æ›´ã‚’ä¿å­˜</button>
                 </div>
            </div>
             <div id="summary-display" class="hidden mt-6">
                <h3 class="text-lg font-semibold mb-2">è¦ç´„çµæœ</h3>
                <div id="summary-result" class="w-full bg-gray-700 p-3 rounded whitespace-pre-wrap"></div>
            </div>
        </div>
    </div>

    <!-- å„ç¨®ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-white mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p id="loading-message" class="text-lg">å‡¦ç†ä¸­ã§ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„...</p>
        </div>
    </div>
    <!-- è¦ç´„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="prompt-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl w-1/2">
            <h2 class="text-xl font-bold mb-6">è¦ç´„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</h2>
            <select id="prompt-select" class="w-full p-3 bg-gray-700 rounded mb-6"></select>
            <div class="flex justify-end space-x-4">
                <button id="cancel-summary" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="confirm-summary" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">è¦ç´„ã‚’å®Ÿè¡Œ</button>
            </div>
        </div>
    </div>
    <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center">
            <h3 id="message-title" class="text-lg font-bold mb-4"></h3>
            <p id="message-body" class="mb-6"></p>
            <button id="message-close-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- å³ã‚¯ãƒªãƒƒã‚¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
    <div id="context-menu" class="hidden absolute bg-gray-700 rounded-md shadow-lg py-1 z-50">
        <a href="#" id="context-rename" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">åå‰ã‚’å¤‰æ›´</a>
        <a href="#" id="context-delete-audio" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å‰Šé™¤</a>
        <a href="#" id="context-delete" class="block px-4 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white">å‰Šé™¤</a>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOMè¦ç´ ã®å–å¾—
            const startButton = document.getElementById('start-button');
            const stopButton = document.getElementById('stop-button');
            const saveButton = document.getElementById('save-button');
            const transcriptArea = document.getElementById('transcript');
            const recordsList = document.getElementById('records-list');
            const rightPanel = document.getElementById('right-panel');
            const closeRightPanel = document.getElementById('close-right-panel');
            const audioPlayer = document.getElementById('audio-player');
            const recordTitle = document.getElementById('record-title');
            const recordDate = document.getElementById('record-date');
            const recordText = document.getElementById('record-text');
            const updateRecordButton = document.getElementById('update-record-button');
            const newFolderButton = document.getElementById('new-folder-button');
            const fileTranscribeButton = document.getElementById('file-transcribe-button');
            const fileInput = document.getElementById('file-input');
            const loadingModal = document.getElementById('loading-modal');
            const loadingMessage = document.getElementById('loading-message');
            const storageUsage = document.getElementById('storage-usage');
            const timerDisplay = document.getElementById('timer');
            const summarizeButton = document.getElementById('summarize-button');
            const promptModal = document.getElementById('prompt-modal');
            const promptSelect = document.getElementById('prompt-select');
            const cancelSummary = document.getElementById('cancel-summary');
            const confirmSummary = document.getElementById('confirm-summary');
            const summaryDisplay = document.getElementById('summary-display');
            const summaryResult = document.getElementById('summary-result');
            const messageModal = document.getElementById('message-modal');
            const messageTitle = document.getElementById('message-title');
            const messageBody = document.getElementById('message-body');
            const messageCloseButton = document.getElementById('message-close-button');
            const contextMenu = document.getElementById('context-menu');
            const contextRename = document.getElementById('context-rename');
            const contextDeleteAudio = document.getElementById('context-delete-audio');
            const contextDelete = document.getElementById('context-delete');
            
            // éŸ³å£°èªè­˜é–¢é€£ã®å¤‰æ•°
            let recognition;
            let isRecording = false;
            let finalTranscript = '';
            let audioChunks = [];
            let mediaRecorder;
            let audioBlob;
            
            // ã‚¿ã‚¤ãƒãƒ¼é–¢é€£
            let timerInterval;
            let seconds = 0;

            // =================================================================================
            // Androidã§ã®éŒ²éŸ³å®‰å®šæ€§å‘ä¸Šã®ãŸã‚ã®ç›£è¦–ã‚¿ã‚¤ãƒãƒ¼ (Watchdog Timer)
            // =================================================================================
            let recognitionWatchdogInterval;
            // ã“ã®å¤‰æ•°ã¯ã€éŸ³å£°èªè­˜ãŒå®Ÿéš›ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹ã‚’è¿½è·¡ã—ã¾ã™ã€‚
            // Web Speech APIã® `onstart` ã¨ `onend` / `onerror` ã‚¤ãƒ™ãƒ³ãƒˆã§æ›´æ–°ã•ã‚Œã¾ã™ã€‚
            let isRecognitionActuallyRunning = false;
            
            const startRecognitionWatchdog = () => {
                // æ—¢ã«ç›£è¦–ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
                if (recognitionWatchdogInterval) return;

                // 2ç§’ã”ã¨ã«éŸ³å£°èªè­˜ã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹
                recognitionWatchdogInterval = setInterval(() => {
                    // isRecordingã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ŒéŒ²éŸ³ä¸­ã€ã¨æœŸå¾…ã—ã¦ã„ã‚‹çŠ¶æ…‹
                    // isRecognitionActuallyRunningã¯APIãŒå®Ÿéš›ã«å‹•ã„ã¦ã„ã‚‹çŠ¶æ…‹
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯éŒ²éŸ³ä¸­ã¨æ€ã£ã¦ã„ã‚‹ã®ã«ã€APIãŒå‹•ã„ã¦ã„ãªã‘ã‚Œã°...
                    if (isRecording && !isRecognitionActuallyRunning) {
                        console.warn('Watchdog detected recognition stall. Restarting...');
                        // èªè­˜ã‚’å†èµ·å‹•
                        try {
                            recognition.start();
                        } catch(e) {
                            console.error("Watchdog failed to restart recognition:", e);
                        }
                    }
                }, 2000); // 2ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
                 console.log("Recognition watchdog started.");
            };

            const stopRecognitionWatchdog = () => {
                if (recognitionWatchdogInterval) {
                    clearInterval(recognitionWatchdogInterval);
                    recognitionWatchdogInterval = null;
                     console.log("Recognition watchdog stopped.");
                }
            };
            // =================================================================================

            // ãƒ‡ãƒ¼ã‚¿ç®¡ç†
            let db;
            let records = [];
            let folders = [];
            let selectedRecord = null;
            
            // è¦ç´„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            const prompts = {
                "simple_summary": { name: "ã‚·ãƒ³ãƒ—ãƒ«è¦ç´„", content: "ä»¥ä¸‹ã®æ–‡ç« ã‚’ç°¡æ½”ã«è¦ç´„ã—ã¦ãã ã•ã„ã€‚:\n\n{text}" },
                "meeting_minutes": { name: "è­°äº‹éŒ²ä½œæˆ", content: "ä»¥ä¸‹ã®ä¼šè­°ã®æ–‡å­—èµ·ã“ã—ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€ä¸»è¦ãªæ±ºå®šäº‹é …ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã€ç™ºè¨€è€…ã”ã¨ã®è¦ç‚¹ã‚’ã¾ã¨ã‚ãŸè­°äº‹éŒ²ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚:\n\n{text}" },
                "action_items": { name: "ToDoæŠ½å‡º", content: "ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€ç™ºç”Ÿã—ãŸã‚¿ã‚¹ã‚¯ã‚„ToDoï¼ˆã‚„ã‚‹ã¹ãã“ã¨ï¼‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚:\n\n{text}" }
            };

            // Web Speech APIã®åˆæœŸåŒ–
            const initializeSpeechRecognition = () => {
                window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!window.SpeechRecognition) {
                    showMessageModal('ã‚¨ãƒ©ãƒ¼', 'ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°èªè­˜ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚');
                    startButton.disabled = true;
                    return;
                }
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP';
                recognition.interimResults = true;
                recognition.continuous = false; // onendã‚’é »ç¹ã«ç™ºç”Ÿã•ã›ã‚‹ãŸã‚ã«falseã«è¨­å®š

                recognition.onstart = () => {
                    isRecognitionActuallyRunning = true; // èªè­˜ãŒé–‹å§‹ã•ã‚ŒãŸ
                    console.log('Recognition started.');
                };

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    transcriptArea.value = finalTranscript + interimTranscript;
                    saveButton.disabled = finalTranscript.trim().length === 0;
                };

                recognition.onerror = (event) => {
                    isRecognitionActuallyRunning = false; // èªè­˜ãŒã‚¨ãƒ©ãƒ¼ã§åœæ­¢
                    console.error('Speech recognition error:', event.error);
                };

                recognition.onend = () => {
                    isRecognitionActuallyRunning = false; // èªè­˜ãŒæ­£å¸¸ã«çµ‚äº†
                    console.log('Recognition ended.');
                    if (isRecording) { // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã¾ã éŒ²éŸ³åœæ­¢ã‚’æŠ¼ã—ã¦ã„ãªã„å ´åˆ
                        try {
                           recognition.start(); // éŒ²éŸ³ã‚’ç¶™ç¶š
                        } catch(e) {
                           console.error("Failed to restart recognition on 'onend':", e);
                        }
                    }
                };
            };
            
            // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
            const initializeDB = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('TranscriptionAppDB', 2);
                    request.onupgradeneeded = (event) => {
                        db = event.target.result;
                        if (!db.objectStoreNames.contains('records')) {
                            db.createObjectStore('records', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('folders')) {
                           db.createObjectStore('folders', { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        db = event.target.result;
                        resolve();
                    };
                    request.onerror = (event) => {
                        console.error('Database error:', event.target.errorCode);
                        reject();
                    };
                });
            };

            // ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿
            const saveData = (storeName, data) => {
                 return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Failed to save data to ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                 });
            };

            const loadAllData = (storeName) => {
                return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => {
                        console.error(`Failed to load data from ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            };
            
            const deleteData = (storeName, id) => {
                return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Failed to delete data from ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            };

            // UIæ›´æ–°
            const renderRecordsList = () => {
                recordsList.innerHTML = '';
                const topLevelRecords = records.filter(r => !r.folderId);
                
                folders.forEach(folder => {
                    const folderEl = createFolderElement(folder);
                    recordsList.appendChild(folderEl);
                });
                topLevelRecords.forEach(record => {
                    const recordEl = createRecordElement(record);
                    recordsList.appendChild(recordEl);
                });
                updateStorageUsage();
            };

            // ãƒ•ã‚©ãƒ«ãƒ€ãƒ»è¨˜éŒ²è¦ç´ ã®ä½œæˆ
            const createFolderElement = (folder) => {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'mb-2';
                folderDiv.dataset.id = folder.id;
                folderDiv.dataset.type = 'folder';

                const folderHeader = document.createElement('div');
                folderHeader.className = 'bg-gray-700 p-2 rounded cursor-pointer flex justify-between items-center';
                folderHeader.textContent = `ğŸ“ ${folder.name}`;
                folderHeader.draggable = true;
                
                folderDiv.appendChild(folderHeader);

                const recordsInFolderDiv = document.createElement('div');
                recordsInFolderDiv.className = 'ml-4 mt-1' + (folder.isOpen ? '' : ' hidden');
                const recordsInFolder = records.filter(r => r.folderId === folder.id);
                recordsInFolder.forEach(record => {
                    recordsInFolderDiv.appendChild(createRecordElement(record));
                });
                folderDiv.appendChild(recordsInFolderDiv);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                folderHeader.addEventListener('click', () => toggleFolder(folder.id));
                folderHeader.addEventListener('contextmenu', (e) => showContextMenu(e, folder.id, 'folder'));
                addDragDropListeners(folderHeader, folder.id, 'folder');

                return folderDiv;
            };

            const createRecordElement = (record) => {
                const div = document.createElement('div');
                div.className = 'record-item bg-gray-700 p-3 mb-2 rounded cursor-pointer border-2 border-transparent';
                div.textContent = record.title;
                div.dataset.id = record.id;
                div.dataset.type = 'record';
                div.draggable = true;

                if (selectedRecord && selectedRecord.id === record.id) {
                    div.classList.add('selected');
                }
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                div.addEventListener('click', () => selectRecord(record.id));
                div.addEventListener('contextmenu', (e) => showContextMenu(e, record.id, 'record'));
                addDragDropListeners(div, record.id, 'record');

                return div;
            };

            // éŒ²éŸ³å‡¦ç†
            const startRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.onstop = () => {
                        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        audioChunks = [];
                    };
                    mediaRecorder.start();
                    recognition.start();
                    startRecognitionWatchdog(); // ç›£è¦–ã‚’é–‹å§‹
                    isRecording = true;
                    finalTranscript = '';
                    transcriptArea.value = '';
                    startButton.classList.add('hidden');
                    stopButton.classList.remove('hidden');
                    saveButton.disabled = true;
                    startTimer();
                } catch (err) {
                    console.error('Error starting recording:', err);
                    showMessageModal('ãƒã‚¤ã‚¯ã‚¨ãƒ©ãƒ¼', 'ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚ŒãŸã‹ã€ãƒã‚¤ã‚¯ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚');
                }
            };

            const stopRecording = () => {
                if (isRecording) {
                    isRecording = false; // onendã§ã®å†é–‹ã‚’æ­¢ã‚ã‚‹
                    mediaRecorder.stop();
                    recognition.stop();
                    stopRecognitionWatchdog(); // ç›£è¦–ã‚’åœæ­¢
                    stopButton.classList.add('hidden');
                    startButton.classList.remove('hidden');
                    saveButton.disabled = finalTranscript.trim().length === 0;
                    stopTimer();
                }
            };
            
            // ã‚¿ã‚¤ãƒãƒ¼å‡¦ç†
            const startTimer = () => {
                seconds = 0;
                timerDisplay.textContent = '00:00:00';
                timerInterval = setInterval(() => {
                    seconds++;
                    const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
                    const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
                    const s = String(seconds % 60).padStart(2, '0');
                    timerDisplay.textContent = `${h}:${m}:${s}`;
                }, 1000);
            };

            const stopTimer = () => {
                clearInterval(timerInterval);
            };

            // è¨˜éŒ²é¸æŠãƒ»è¡¨ç¤º
            const selectRecord = (id) => {
                selectedRecord = records.find(r => r.id === id);
                if (selectedRecord) {
                    document.querySelectorAll('.record-item').forEach(el => {
                        el.classList.toggle('selected', el.dataset.id === id);
                    });
                    
                    recordTitle.textContent = selectedRecord.title;
                    recordDate.textContent = new Date(selectedRecord.timestamp).toLocaleString();
                    recordText.value = selectedRecord.transcript;

                    if (selectedRecord.audioBlob) {
                        const audioUrl = URL.createObjectURL(selectedRecord.audioBlob);
                        audioPlayer.src = audioUrl;
                        audioPlayer.style.display = 'block';
                    } else {
                        audioPlayer.style.display = 'none';
                    }
                    rightPanel.classList.remove('hidden');
                    rightPanel.classList.add('flex');
                    summaryDisplay.classList.add('hidden');
                }
            };

            const deselectAll = () => {
                selectedRecord = null;
                document.querySelectorAll('.record-item.selected').forEach(el => el.classList.remove('selected'));
                rightPanel.classList.add('hidden');
                rightPanel.classList.remove('flex');
            };

            // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            const migrateFromLocalStorage = async () => {
                const oldRecords = localStorage.getItem('transcripts');
                if (oldRecords) {
                    const parsedRecords = JSON.parse(oldRecords);
                    if (Array.isArray(parsedRecords) && parsedRecords.length > 0) {
                        const needsMigration = await loadAllData('records').then(data => data.length === 0);
                        if(needsMigration) {
                           if(confirm("ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’ç§»è¡Œã—ã¾ã™ã‹ï¼Ÿï¼ˆã“ã®æ“ä½œã¯ä¸€åº¦ã ã‘è¡Œã‚ã‚Œã¾ã™ï¼‰")) {
                               for (const record of parsedRecords) {
                                   await saveData('records', {
                                       id: record.id || `migrated-${Date.now()}-${Math.random()}`,
                                       title: record.title || `ç„¡é¡Œã®è¨˜éŒ² ${new Date(record.timestamp).toLocaleDateString()}`,
                                       transcript: record.transcript,
                                       timestamp: record.timestamp,
                                       audioBlob: null // å¤ã„ãƒ‡ãƒ¼ã‚¿ã«ã¯éŸ³å£°ãŒãªã„
                                   });
                               }
                               localStorage.removeItem('transcripts'); // ç§»è¡Œå¾Œã«å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
                               showMessageModal('ç§»è¡Œå®Œäº†', 'ãƒ‡ãƒ¼ã‚¿ã®ç§»è¡ŒãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
                           }
                        }
                    }
                }
            };
            
            // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡è¨ˆç®—
            const updateStorageUsage = async () => {
                if (navigator.storage && navigator.storage.estimate) {
                    const estimate = await navigator.storage.estimate();
                    const usageMb = (estimate.usage / 1024 / 1024).toFixed(2);
                    const quotaMb = (estimate.quota / 1024 / 1024).toFixed(2);
                    storageUsage.textContent = `ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡: ${usageMb} MB / ${quotaMb} MB`;
                }
            };
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            const setupEventListeners = () => {
                startButton.addEventListener('click', startRecording);
                stopButton.addEventListener('click', stopRecording);
                
                saveButton.addEventListener('click', async () => {
                    const title = prompt('è¨˜éŒ²ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', `éŒ²éŸ³ ${new Date().toLocaleString()}`);
                    if (title) {
                        const newRecord = {
                            id: `record-${Date.now()}`,
                            title: title,
                            transcript: finalTranscript,
                            timestamp: Date.now(),
                            audioBlob: audioBlob
                        };
                        await saveData('records', newRecord);
                        records.push(newRecord);
                        renderRecordsList();
                        transcriptArea.value = '';
                        finalTranscript = '';
                        saveButton.disabled = true;
                        showMessageModal('ä¿å­˜å®Œäº†', `ã€Œ${title}ã€ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚`);
                    }
                });

                updateRecordButton.addEventListener('click', async () => {
                    if (selectedRecord) {
                        selectedRecord.transcript = recordText.value;
                        await saveData('records', selectedRecord);
                        showMessageModal('æ›´æ–°å®Œäº†', `ã€Œ${selectedRecord.title}ã€ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚`);
                    }
                });
                
                closeRightPanel.addEventListener('click', deselectAll);
                
                newFolderButton.addEventListener('click', async () => {
                    const name = prompt("æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
                    if (name) {
                        const newFolder = { id: `folder-${Date.now()}`, name: name, isOpen: true };
                        await saveData('folders', newFolder);
                        folders.push(newFolder);
                        renderRecordsList();
                    }
                });

                fileTranscribeButton.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', handleFileUpload);
                
                summarizeButton.addEventListener('click', () => {
                    promptSelect.innerHTML = '';
                    Object.entries(prompts).forEach(([key, value]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = value.name;
                        promptSelect.appendChild(option);
                    });
                    promptModal.classList.remove('hidden');
                    promptModal.classList.add('flex');
                });
                cancelSummary.addEventListener('click', () => {
                    promptModal.classList.add('hidden');
                    promptModal.classList.remove('flex');
                });
                confirmSummary.addEventListener('click', handleSummary);
                
                messageCloseButton.addEventListener('click', () => {
                    messageModal.classList.add('hidden');
                    messageModal.classList.remove('flex');
                });
                
                 // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼é–¢é€£
                document.addEventListener('click', () => contextMenu.classList.add('hidden'));
                contextMenu.addEventListener('click', e => e.stopPropagation());
                
                contextRename.addEventListener('click', handleRename);
                contextDelete.addEventListener('click', handleDelete);
                contextDeleteAudio.addEventListener('click', handleDeleteAudio);
            };

            // ãã®ä»–ã®é–¢æ•° (ãƒ•ã‚©ãƒ«ãƒ€æ“ä½œã€ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã€ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ãªã©)
            const toggleFolder = async (id) => {
                const folder = folders.find(f => f.id === id);
                if (folder) {
                    folder.isOpen = !folder.isOpen;
                    await saveData('folders', folder);
                    renderRecordsList();
                }
            };

            const showContextMenu = (e, id, type) => {
                e.preventDefault();
                e.stopPropagation();
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.classList.remove('hidden');
                contextMenu.dataset.id = id;
                contextMenu.dataset.type = type;
                contextDeleteAudio.style.display = (type === 'record') ? 'block' : 'none';
            };
            
            const handleRename = async () => {
                const id = contextMenu.dataset.id;
                const type = contextMenu.dataset.type;
                contextMenu.classList.add('hidden');
                if(type === 'record') {
                    const record = records.find(r => r.id === id);
                    if(record){
                        const newName = prompt("æ–°ã—ã„è¨˜éŒ²åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", record.title);
                        if (newName) {
                            record.title = newName;
                            await saveData('records', record);
                            if(selectedRecord && selectedRecord.id === id) recordTitle.textContent = newName;
                        }
                    }
                } else if (type === 'folder') {
                    const folder = folders.find(f => f.id === id);
                    if(folder) {
                        const newName = prompt("æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", folder.name);
                        if (newName) {
                            folder.name = newName;
                            await saveData('folders', folder);
                        }
                    }
                }
                renderRecordsList();
            };

            const handleDelete = async () => {
                const id = contextMenu.dataset.id;
                const type = contextMenu.dataset.type;
                contextMenu.classList.add('hidden');

                if (type === 'record') {
                    const record = records.find(r => r.id === id);
                    if (record && confirm(`è¨˜éŒ²ã€Œ${record.title}ã€ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                        await deleteData('records', id);
                        records = records.filter(r => r.id !== id);
                        if (selectedRecord && selectedRecord.id === id) deselectAll();
                    }
                } else if (type === 'folder') {
                    const folder = folders.find(f => f.id === id);
                    const recordsInFolder = records.filter(r => r.folderId === id);
                    if (folder && confirm(`ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${folder.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nä¸­ã®${recordsInFolder.length}å€‹ã®è¨˜éŒ²ã‚‚å…¨ã¦å‰Šé™¤ã•ã‚Œã¾ã™ã€‚`)) {
                        for(const record of recordsInFolder) {
                            await deleteData('records', record.id);
                        }
                        await deleteData('folders', id);
                        records = records.filter(r => r.folderId !== id);
                        folders = folders.filter(f => f.id !== id);
                    }
                }
                renderRecordsList();
            };
            
            const handleDeleteAudio = async () => {
                 const id = contextMenu.dataset.id;
                 contextMenu.classList.add('hidden');
                 const record = records.find(r => r.id === id);
                 if (record && confirm(`ã€Œ${record.title}ã€ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿãƒ†ã‚­ã‚¹ãƒˆã¯æ®‹ã‚Šã¾ã™ã€‚`)) {
                     delete record.audioBlob;
                     await saveData('records', record);
                     showMessageModal('å‰Šé™¤å®Œäº†', 'éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
                     if (selectedRecord && selectedRecord.id === id) selectRecord(id);
                     await updateStorageUsage();
                 }
            };
            
            const addDragDropListeners = (element, id, type) => {
                element.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    e.dataTransfer.setData('text/plain', JSON.stringify({id, type}));
                    element.classList.add('dragging');
                });
                element.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    element.classList.remove('dragging');
                });
                 element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (type === 'folder' || !e.currentTarget.dataset.id) { // ãƒ•ã‚©ãƒ«ãƒ€ã¾ãŸã¯ãƒªã‚¹ãƒˆã®ãƒ«ãƒ¼ãƒˆ
                        e.stopPropagation();
                        element.classList.add('drag-over');
                    }
                });
                element.addEventListener('dragleave', (e) => {
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                });
                element.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                    const droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    if (droppedData.type === 'record') {
                        const record = records.find(r => r.id === droppedData.id);
                        if(record) {
                            if (type === 'folder') { // ãƒ•ã‚©ãƒ«ãƒ€ã«ãƒ‰ãƒ­ãƒƒãƒ—
                                record.folderId = id;
                            }
                             await saveData('records', record);
                             renderRecordsList();
                        }
                    }
                });
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const apiKey = prompt("Hugging Face APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
                if (!apiKey) return;
                
                loadingMessage.textContent = "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...";
                loadingModal.classList.remove('hidden');

                try {
                    const response = await fetch("https://api-inference.huggingface.co/models/openai/whisper-large-v3", {
                        headers: { Authorization: `Bearer ${apiKey}` },
                        method: "POST",
                        body: file,
                    });
                    const result = await response.json();
                    
                    if(result.text) {
                        const newRecord = {
                            id: `record-${Date.now()}`,
                            title: file.name,
                            transcript: result.text,
                            timestamp: Date.now(),
                            audioBlob: new Blob([file], {type: file.type})
                        };
                        await saveData('records', newRecord);
                        records.push(newRecord);
                        renderRecordsList();
                        selectRecord(newRecord.id);
                    } else {
                        throw new Error(result.error || "APIã‹ã‚‰ã®å¿œç­”ãŒä¸æ­£ã§ã™ã€‚");
                    }
                } catch (error) {
                    console.error('File transcription error:', error);
                    showMessageModal('APIã‚¨ãƒ©ãƒ¼', `æ–‡å­—èµ·ã“ã—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                } finally {
                    loadingModal.classList.add('hidden');
                    fileInput.value = ''; // åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
                }
            };
            
            const handleSummary = async () => {
                const apiKey = prompt("Gemini APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:");
                if (!apiKey || !selectedRecord) return;
                
                promptModal.classList.add('hidden');
                loadingMessage.textContent = "è¦ç´„ã‚’ç”Ÿæˆä¸­ã§ã™...";
                loadingModal.classList.remove('hidden');
                
                try {
                    const selectedPromptKey = promptSelect.value;
                    const promptTemplate = prompts[selectedPromptKey].content;
                    const fullPrompt = promptTemplate.replace('{text}', selectedRecord.transcript);

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    
                    if(!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`APIãƒªã‚¯ã‚¨ã‚¹ãƒˆå¤±æ•—: ${errorBody.error.message}`);
                    }

                    const result = await response.json();
                    const summary = result.candidates[0].content.parts[0].text;
                    
                    summaryResult.textContent = summary;
                    summaryDisplay.classList.remove('hidden');
                    
                    // ä¸­å¤®ãƒ‘ãƒãƒ«ã‚’è¦ç´„çµæœè¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
                    document.getElementById('main-controls').classList.add('hidden');
                    document.getElementById('transcript').parentElement.classList.add('hidden'); // textareaã¨ãƒœã‚¿ãƒ³ã‚’å«ã‚€div
                    document.getElementById('center-panel').insertAdjacentElement('afterbegin', summaryDisplay);

                } catch (error) {
                    console.error('Summary generation error:', error);
                    showMessageModal('APIã‚¨ãƒ©ãƒ¼', `è¦ç´„ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                } finally {
                    loadingModal.classList.add('hidden');
                }
            };
            
            const showMessageModal = (title, body) => {
                 messageTitle.textContent = title;
                 messageBody.textContent = body;
                 messageModal.classList.remove('hidden');
                 messageModal.classList.add('flex');
            };

            // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            const initializeApp = async () => {
                initializeSpeechRecognition();
                await initializeDB();
                await migrateFromLocalStorage();
                [records, folders] = await Promise.all([loadAllData('records'), loadAllData('folders')]);
                renderRecordsList();
                setupEventListeners();
                updateStorageUsage();
            };
            
            initializeApp();
        });
    </script>
</body>
</html>
