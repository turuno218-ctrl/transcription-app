<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文字起こしアプリ V1.6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        
        /* レスポンシブ対応 */
        .record-item.selected { border: 2px solid #3b82f6; background-color: #374151; }
        .folder-item.drop-hover { background-color: #3b82f6; }
        .record-item.is-dragging { opacity: 0.5; }
        audio { width: 100%; }

        @media (max-width: 768px) {
            #left-panel, #right-panel {
                position: fixed;
                top: 0;
                height: 100%;
                z-index: 40;
                transition: transform 0.3s ease-in-out;
                width: 80%;
                max-width: 300px;
            }
            #left-panel {
                left: 0;
                transform: translateX(-100%);
            }
            #left-panel.open {
                transform: translateX(0);
            }
            #right-panel {
                right: 0;
                transform: translateX(100%);
            }
            #right-panel.open {
                transform: translateX(0);
            }
            #overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
                z-index: 30;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex h-full">
    <div class="container mx-auto max-w-7xl flex-grow flex flex-col md:flex-row rounded-xl shadow-lg overflow-hidden my-0 md:my-4 h-full">

        <!-- モバイル用ヘッダー -->
        <header class="md:hidden flex items-center justify-between p-2 bg-gray-800 border-b border-gray-700">
            <button id="mobile-menu-button" class="p-2 rounded-md hover:bg-gray-700">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
            </button>
            <h1 class="text-lg font-bold">文字起こしアプリ</h1>
            <button id="mobile-controls-button" class="p-2 rounded-md hover:bg-gray-700">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 16v-2m-7-6H3m18 0h-2m-4 4l-1.4-1.4M8.4 8.4L7 7m9.9 9.9l-1.4-1.4M12 18a6 6 0 100-12 6 6 0 000 12z" /></svg>
            </button>
        </header>

        <!-- 左カラム: 履歴管理とナビゲーション -->
        <aside id="left-panel" class="w-64 bg-gray-800 p-4 flex-col space-y-4 border-r border-gray-700 hidden md:flex">
            <!-- ... V1.5と同じコンテンツ ... -->
        </aside>

        <!-- 中央カラム: メインコンテンツ -->
        <main class="flex-grow main-content flex flex-col p-2 md:p-6 bg-gray-800 border-r border-gray-700 min-w-0 h-full">
            <!-- ... V1.5と同じコンテンツ ... -->
        </main>

        <!-- 右カラム: コントロールパネル -->
        <aside id="right-panel" class="w-full md:w-96 bg-gray-800 p-6 flex-col space-y-6 hidden md:flex">
            <!-- ... V1.5と同じコンテンツ ... -->
        </aside>

        <!-- オーバーレイ -->
        <div id="overlay" class="hidden"></div>
    </div>
    
    <!-- モーダル (V1.5と同じ) -->
    <!-- ... V1.5のモーダルHTML ... -->
    
    <!-- 汎用入力モーダル (新規追加) -->
    <div id="input-prompt-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
            <h3 id="input-prompt-title" class="text-lg font-bold mb-4"></h3>
            <p id="input-prompt-label" class="text-sm text-gray-400 mb-2"></p>
            <input type="text" id="input-prompt-field" class="w-full bg-gray-700 text-gray-100 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex justify-end space-x-4 mt-4">
                <button id="input-prompt-cancel" class="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-lg">キャンセル</button>
                <button id="input-prompt-confirm" class="bg-blue-600 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <script>
        // V1.5のJavaScriptをベースに修正
        document.addEventListener('DOMContentLoaded', () => {
            // ... (DOM Elements, State variables, Watchdog Timer, DB functions from V1.5) ...

            // --- 新規追加/修正箇所 ---

            // モバイルUI用DOM要素
            const mobileMenuButton = document.getElementById('mobile-menu-button');
            const mobileControlsButton = document.getElementById('mobile-controls-button');
            const leftPanel = document.getElementById('left-panel');
            const rightPanel = document.getElementById('right-panel');
            const overlay = document.getElementById('overlay');
            
            // 汎用入力モーダル用DOM要素
            const inputPromptModal = document.getElementById('input-prompt-modal');
            const inputPromptTitle = document.getElementById('input-prompt-title');
            const inputPromptLabel = document.getElementById('input-prompt-label');
            const inputPromptField = document.getElementById('input-prompt-field');
            const inputPromptCancel = document.getElementById('input-prompt-cancel');
            const inputPromptConfirm = document.getElementById('input-prompt-confirm');

            // --- UI & View Management (修正) ---
            const showConfirmationModal = (message, onConfirm) => {
                deleteConfirmMessage.textContent = message;
                deleteConfirmModal.classList.remove('hidden');
                deleteConfirmModal.classList.add('flex');
                
                // 以前のイベントリスナーを削除して多重実行を防ぐ
                const newConfirmButton = confirmDeleteButton.cloneNode(true);
                confirmDeleteButton.parentNode.replaceChild(newConfirmButton, confirmDeleteButton);
                confirmDeleteButton = newConfirmButton; // Re-assign to the new element
                
                newConfirmButton.onclick = () => {
                    onConfirm();
                    deleteConfirmModal.classList.add('hidden');
                };
            };
            
            const showInputPrompt = (config) => {
                return new Promise((resolve) => {
                    inputPromptTitle.textContent = config.title;
                    inputPromptLabel.textContent = config.label;
                    inputPromptField.value = config.defaultValue || '';
                    inputPromptField.placeholder = config.placeholder || '';
                    inputPromptModal.classList.remove('hidden');
                    inputPromptModal.classList.add('flex');
                    
                    const handleConfirm = () => {
                        cleanup();
                        resolve(inputPromptField.value);
                    };

                    const handleCancel = () => {
                        cleanup();
                        resolve(null);
                    };
                    
                    const cleanup = () => {
                        inputPromptConfirm.removeEventListener('click', handleConfirm);
                        inputPromptCancel.removeEventListener('click', handleCancel);
                        inputPromptModal.classList.add('hidden');
                    }
                    
                    inputPromptConfirm.addEventListener('click', handleConfirm);
                    inputPromptCancel.addEventListener('click', handleCancel);
                });
            };

            const resetData = () => {
                 showConfirmationModal('全ての記録、フォルダ、設定を削除します。よろしいですか？', async () => {
                    await db.transaction(['records', 'folders', 'settings'], 'readwrite').objectStore('records').clear();
                    await db.transaction(['records', 'folders', 'settings'], 'readwrite').objectStore('folders').clear();
                    await db.transaction(['records', 'folders', 'settings'], 'readwrite').objectStore('settings').clear();
                    records = []; folders = []; promptTemplates = []; geminiApiKey = ''; huggingFaceApiKey = '';
                    await initializeApp();
                    showMessageModal('初期化完了', '全てのデータを初期化しました。');
                 });
            };


            // --- Attach Event Listeners (大幅に修正) ---
            const attachAllEventListeners = () => {
                // Mobile UI Listeners
                mobileMenuButton.addEventListener('click', () => {
                    leftPanel.classList.toggle('open');
                    overlay.classList.toggle('hidden');
                });
                mobileControlsButton.addEventListener('click', () => {
                    rightPanel.classList.toggle('open');
                    overlay.classList.toggle('hidden');
                });
                overlay.addEventListener('click', () => {
                    leftPanel.classList.remove('open');
                    rightPanel.classList.remove('open');
                    overlay.classList.add('hidden');
                });

                // ... (homeButton, recordButton etc. from V1.5) ...

                addFolderButton.addEventListener('click', async () => {
                    const name = await showInputPrompt({
                        title: 'フォルダ作成',
                        label: '新しいフォルダ名を入力してください',
                        placeholder: '例：プロジェクトA'
                    });
                    if (name && name.trim()) { 
                        const newFolder = { id: crypto.randomUUID(), name: name.trim() }; 
                        await saveData('folders', newFolder); 
                        folders.push(newFolder); 
                        renderFolders(); 
                    }
                });

                clearDataButton.addEventListener('click', resetData);

                addTemplateButton.addEventListener('click', async () => {
                    const title = await showInputPrompt({title: 'テンプレート作成', label: '新しいテンプレートのタイトル'});
                    if(!title) return;
                    const text = await showInputPrompt({title: 'テンプレート作成', label: '新しいプロンプトの内容'});
                    if(!text) return;
                    promptTemplates.push({title, text});
                    await saveData('settings', {key: 'promptTemplates', value: promptTemplates});
                    renderPromptTemplates();
                });

                // ... (document click listener for context menu from V1.5) ...
                
                contextRename.addEventListener('click', async () => {
                    const id = contextMenu.dataset.id; const type = contextMenu.dataset.type; contextMenu.classList.add('hidden');
                    if (type === 'folder') {
                        const folder = folders.find(f => f.id === id);
                        if (folder) { 
                            const newName = await showInputPrompt({title: 'フォルダ名変更', label:'新しいフォルダ名', defaultValue: folder.name});
                            if (newName && newName.trim()) { folder.name = newName.trim(); await saveData('folders', folder); renderFolders(); } 
                        }
                    } else if (type === 'record') {
                        const record = records.find(r => r.id === id);
                        if (record) { 
                            const newTitle = await showInputPrompt({title: '記録タイトル変更', label:'新しいタイトル', defaultValue: record.title});
                            if (newTitle && newTitle.trim()) { record.title = newTitle.trim(); await saveData('records', record); if(selectedRecord && selectedRecord.id === id) contentTitle.textContent = `記録: ${record.title}`; deselectAll(); } 
                        }
                    }
                });

                contextDelete.addEventListener('click', () => {
                    const id = contextMenu.dataset.id; const type = contextMenu.dataset.type; contextMenu.classList.add('hidden');
                    if (type === 'folder') {
                        const folder = folders.find(f => f.id === id);
                        if (folder) {
                            if(records.some(r => r.folderId === id)) { showMessageModal('削除不可', 'フォルダ内に記録があるため削除できません。'); return; }
                            showConfirmationModal(`フォルダ「${folder.name}」を削除しますか？`, async () => { 
                                await deleteData('folders', id); folders = folders.filter(f => f.id !== id); renderFolders(); deselectAll(); 
                            });
                        }
                    } else if (type === 'record') {
                        const record = records.find(r => r.id === id);
                        if (record) {
                            showConfirmationModal(`記録「${record.title}」を削除しますか？\n(音声ファイルも一緒に削除されます)`, async () => { 
                                await deleteData('records', id); records = records.filter(r => r.id !== id); showMessageModal('削除完了', `記録「${record.title}」を削除しました。`); deselectAll(); await updateStorageUsage(); 
                            });
                        }
                    }
                });

                contextDeleteAudio.addEventListener('click', () => {
                    const id = contextMenu.dataset.id; contextMenu.classList.add('hidden');
                    const record = records.find(r => r.id === id);
                    if (record) {
                        showConfirmationModal(`「${record.title}」の音声ファイルのみを削除しますか？\n文字起こしテキストは残ります。`, async () => {
                            delete record.audioBlob;
                            await saveData('records', record);
                            showMessageModal('削除完了', '音声ファイルを削除しました。');
                            if (selectedRecord && selectedRecord.id === id) selectRecord(id); else deselectAll();
                            await updateStorageUsage();
                        });
                    }
                });
                
                cancelDeleteButton.addEventListener('click', () => { deleteConfirmModal.classList.add('hidden'); deleteConfirmModal.classList.remove('flex'); });

                // V1.5の他のリスナーもここに含める
                // ... (homeButton, recordButton, start/cancel recording, summarizeButton, etc.)
            };
            
            initializeApp();
        });
    </script>
</body>
</html>
