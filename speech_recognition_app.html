<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文字起こしアプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        .main-content {
            flex-grow: 1;
        }
        .text-area {
            min-height: 200px;
            height: 100%;
            resize: none;
        }
        .record-item.selected {
            border: 2px solid #3b82f6;
            background-color: #374151;
        }
        .folder-item.drop-hover {
            background-color: #3b82f6; /* blue-500 */
        }
        .record-item.is-dragging {
            opacity: 0.5;
        }
        audio {
            width: 100%;
        }
        /* レイアウト崩れ防止 */
        #transcript-container p, #transcript-container pre {
            word-break: break-all;
            white-space: pre-wrap; /* 改行を維持 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex min-h-screen">
    <div id="app-version" class="fixed top-2 right-2 text-xs text-gray-500 bg-gray-800 px-2 py-1 rounded-md z-50"></div>
    <div class="container mx-auto max-w-7xl flex-grow flex flex-col md:flex-row shadow-lg md:rounded-xl md:my-4 overflow-hidden">

        <!-- 左カラム: 履歴管理とナビゲーション -->
        <aside class="w-full md:w-64 bg-gray-800 p-4 flex flex-col space-y-4 border-b md:border-r md:border-b-0 border-gray-700 flex-shrink-0">
            <div class="flex items-center justify-center mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-blue-500" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5z"/>
                    <path d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                </svg>
            </div>
            
            <button id="home-button" class="flex items-center space-x-2 p-3 rounded-lg hover:bg-gray-700 transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
                </svg>
                <span>ホーム</span>
            </button>
            
            <div class="relative w-full">
                <input type="text" placeholder="記録を検索..." class="w-full p-2 pl-10 rounded-lg bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>
            </div>
            
            <div class="flex-grow overflow-y-auto space-y-2">
                <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mt-4">フォルダ</h3>
                <ul id="folder-list" class="space-y-1">
                    <!-- フォルダはJavaScriptで動的に追加 -->
                </ul>
                <button id="add-folder-button" class="w-full text-blue-400 text-sm mt-2 hover:underline">新しいフォルダを作成</button>
            </div>

            <div id="storage-usage" class="text-xs text-gray-400 mt-auto p-2 border-t border-gray-700">
                <!-- ストレージ使用量がここに表示される -->
            </div>
        </aside>

        <!-- 中央カラム: メインコンテンツ -->
        <main class="flex-grow main-content flex flex-col p-6 bg-gray-800 border-b md:border-r md:border-b-0 border-gray-700 min-w-0">
            <div id="content-display" class="flex-grow flex flex-col">
                <h2 id="content-title" class="text-xl font-bold mb-4">最近の記録履歴</h2>
                <div id="recent-history" class="space-y-4 flex-grow overflow-y-auto" data-id="root" data-type="folder">
                    <!-- 記録はJavaScriptで動的に追加 -->
                </div>
                
                <!-- 文字起こしコンテナ -->
                <div id="transcript-container" class="hidden flex-grow flex flex-col p-4 bg-gray-700 rounded-lg overflow-y-auto space-y-4 overflow-x-hidden">
                     <!-- This will be populated by JS -->
                </div>

                <!-- 要約コンテナ -->
                 <div id="summary-container" class="hidden flex-grow flex flex-col p-4 bg-gray-700 rounded-lg overflow-y-auto">
                    <!-- This will be populated by JS for prompt selection or summary result -->
                </div>
            </div>
        </main>

        <!-- 右カラム: コントロールパネル -->
        <div id="right-panel" class="w-full md:w-[25rem] bg-gray-800 p-6 flex flex-col space-y-6 flex-shrink-0">
            <div id="timer-display" class="hidden text-center text-4xl font-mono text-gray-300 py-4 mb-4 bg-gray-700 rounded-lg">
                00:00:00
            </div>
            <div id="control-buttons" class="flex flex-col space-y-4">
                <button id="record-button" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-200">
                    録音を開始
                </button>
                <button id="summarize-button" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    要約を開始
                </button>
                <label for="audio-upload" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-200 cursor-pointer text-center">
                    ファイルから文字起こし
                </label>
                <input type="file" id="audio-upload" accept="audio/*" class="hidden">
                <button id="settings-button" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-200">
                    設定
                </button>
            </div>
            <!-- 右カラム表示エリア -->
            <div id="right-panel-display" class="flex-grow bg-gray-700 rounded-lg p-4 overflow-y-auto hidden">
                <div id="right-panel-content" class="text-sm leading-relaxed whitespace-pre-wrap space-y-4">
                    <!-- 音声プレーヤー or 要約結果がここに表示される -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modals and Context Menu (HTML unchanged) -->
    <div id="title-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
            <h3 class="text-lg font-bold mb-4">記録タイトルを入力</h3>
            <input type="text" id="record-title-input" class="w-full bg-gray-700 text-gray-100 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="例：新製品企画会議">
            <div class="flex justify-end space-x-4 mt-4">
                <button id="cancel-recording-button" class="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-lg">キャンセル</button>
                <button id="start-recording-button" class="bg-blue-600 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-lg">録音を開始</button>
            </div>
        </div>
    </div>
    <div id="settings-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full flex flex-col max-h-[90vh]">
            <h3 class="text-lg font-bold mb-4">設定</h3>
            <div class="space-y-6 overflow-y-auto pr-2">
                <div>
                    <h4 class="font-bold text-gray-300 mb-2">AI API設定</h4>
                    <p class="text-sm text-gray-400 mb-2">Gemini APIキー (要約機能用)</p>
                    <input type="password" id="gemini-api-key" class="w-full bg-gray-700 text-gray-100 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="APIキー">
                
                    <p class="text-sm text-gray-400 mt-4 mb-2">Hugging Face APIキー (ファイル文字起こし用)</p>
                    <input type="password" id="huggingface-api-key" class="w-full bg-gray-700 text-gray-100 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="APIキー">
                </div>
                <div class="space-y-4">
                    <h4 class="font-bold text-gray-300 mb-2">要約プロンプトのテンプレート</h4>
                    <p class="text-sm text-gray-400 mb-2">要約の目的に応じて、プロンプトをカスタマイズできます。</p>
                    <div id="prompt-templates" class="space-y-4"></div>
                    <button id="add-template-button" class="text-blue-400 text-sm hover:underline mt-2">新しいテンプレートを作成</button>
                </div>
                <div>
                    <h4 class="font-bold text-gray-300 mb-2">データ管理</h4>
                    <p class="text-sm text-gray-400 mb-2">すべての記録履歴とフォルダを削除します。</p>
                    <button id="clear-data-button" class="bg-red-600 hover:bg-red-500 text-white font-medium py-2 px-4 rounded-lg">初期化</button>
                </div>
            </div>
            <div class="flex justify-end mt-6 pt-4 border-t border-gray-700">
                <button id="close-settings-button" class="bg-blue-600 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>
    <div id="delete-confirm-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
            <h3 class="text-lg font-bold mb-4">削除確認</h3>
            <p id="delete-confirm-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-delete-button" class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-medium py-2 px-4 rounded-lg">キャンセル</button>
                <button id="confirm-delete-button" class="bg-red-600 hover:bg-red-500 text-white font-medium py-2 px-4 rounded-lg">削除</button>
            </div>
        </div>
    </div>
    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full">
            <h3 id="modal-title" class="text-lg font-bold mb-4"></h3>
            <p id="modal-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end space-x-4">
                <button id="close-modal-button" class="bg-blue-600 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-lg">OK</button>
            </div>
        </div>
    </div>
    <div id="context-menu" class="fixed z-50 bg-gray-700 rounded-lg shadow-lg py-1 hidden">
        <button id="context-rename" class="w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-600">名前を変更</button>
        <button id="context-delete-audio" class="w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-600">音声ファイルのみ削除</button>
        <button id="context-delete" class="w-full text-left px-4 py-2 text-sm text-gray-300 hover:bg-gray-600">削除</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const homeButton = document.getElementById('home-button');
            const contentTitle = document.getElementById('content-title');
            const recentHistory = document.getElementById('recent-history');
            const transcriptContainer = document.getElementById('transcript-container');
            const summaryContainer = document.getElementById('summary-container');
            const recordButton = document.getElementById('record-button');
            const summarizeButton = document.getElementById('summarize-button');
            const settingsButton = document.getElementById('settings-button');
            const rightPanelDisplay = document.getElementById('right-panel-display');
            const rightPanelContent = document.getElementById('right-panel-content');
            const audioUpload = document.getElementById('audio-upload');
            const addFolderButton = document.getElementById('add-folder-button');
            const folderList = document.getElementById('folder-list');
            const contextMenu = document.getElementById('context-menu');
            const contextRename = document.getElementById('context-rename');
            const contextDelete = document.getElementById('context-delete');
            const contextDeleteAudio = document.getElementById('context-delete-audio');
            const storageUsageEl = document.getElementById('storage-usage');
            const timerDisplay = document.getElementById('timer-display');
            const appVersionEl = document.getElementById('app-version');
            
            // Modals
            const titleModal = document.getElementById('title-modal');
            const recordTitleInput = document.getElementById('record-title-input');
            const startRecordingButton = document.getElementById('start-recording-button');
            const cancelRecordingButton = document.getElementById('cancel-recording-button');
            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsButton = document.getElementById('close-settings-button');
            const geminiApiKeyInput = document.getElementById('gemini-api-key');
            const huggingFaceApiKeyInput = document.getElementById('huggingface-api-key');
            const promptTemplatesContainer = document.getElementById('prompt-templates');
            const addTemplateButton = document.getElementById('add-template-button');
            const clearDataButton = document.getElementById('clear-data-button');
            const messageModal = document.getElementById('message-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const closeModalButton = document.getElementById('close-modal-button');
            const deleteConfirmModal = document.getElementById('delete-confirm-modal');
            const deleteConfirmMessage = document.getElementById('delete-confirm-message');
            const cancelDeleteButton = document.getElementById('cancel-delete-button');
            const confirmDeleteButton = document.getElementById('confirm-delete-button');

            // State variables
            const APP_VERSION = "1.4";
            const GEMINI_API_ENDPOINT = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";
            const WHISPER_API_ENDPOINT = "https://api-inference.huggingface.co/models/openai/whisper-large-v3";
            let recognition;
            let mediaRecorder;
            let audioChunks = [];
            let localStream;
            let currentTranscript = '';
            let isRecording = false;
            let selectedRecord = null;
            let db;
            let recordingTimerInterval;
            let recordingStartTime;
            
            // Data
            let promptTemplates = [];
            let folders = [];
            let geminiApiKey = '';
            let huggingFaceApiKey = '';
            let records = [];

            // --- IndexedDB Database ---
            const DB_NAME = 'TranscriptionAppDB', DB_VERSION = 1;
            const initDB = () => new Promise((resolve, reject) => { const r = indexedDB.open(DB_NAME, DB_VERSION); r.onupgradeneeded = e => { const d = e.target.result; if (!d.objectStoreNames.contains('records')) d.createObjectStore('records', { keyPath: 'id' }); if (!d.objectStoreNames.contains('folders')) d.createObjectStore('folders', { keyPath: 'id' }); if (!d.objectStoreNames.contains('settings')) d.createObjectStore('settings', { keyPath: 'key' }); }; r.onsuccess = e => { db = e.target.result; resolve(db); }; r.onerror = e => reject(e.target.error); });
            const saveData = (s, d) => new Promise((resolve, reject) => { if (!db) return reject("DB not init"); const t = db.transaction(s, 'readwrite'); t.objectStore(s).put(d); t.oncomplete = () => resolve(); t.onerror = e => reject(e.target.error); });
            const getAllData = (s) => new Promise((resolve, reject) => { if (!db) return reject("DB not init"); const r = db.transaction(s, 'readonly').objectStore(s).getAll(); r.onsuccess = e => resolve(e.target.result); r.onerror = e => reject(e.target.error); });
            const deleteData = (s, i) => new Promise((resolve, reject) => { if (!db) return reject("DB not init"); const t = db.transaction(s, 'readwrite'); t.objectStore(s).delete(i); t.oncomplete = () => resolve(); t.onerror = e => reject(e.target.error); });

            // --- Initialization ---
            const initializeApp = async () => {
                appVersionEl.textContent = `v${APP_VERSION}`;
                await initDB();
                await migrateFromLocalStorage();
                await loadDataFromDB();
                attachAllEventListeners();
                renderUI();
                setupRecognition();
                updateStorageUsage();
            };

            const migrateFromLocalStorage = async () => { /* ... (same as before) ... */ };
            const renderUI = () => { renderPromptTemplates(); renderFolders(); renderRecords(records.filter(r => !r.folderId), recentHistory); };
            const loadDataFromDB = async () => { /* ... (same as before) ... */ };
            const setupDefaultTemplates = async () => { /* ... (same as before) ... */ };
            const resetData = async () => { /* ... (same as before) ... */ };
            
            // --- UI & View Management ---
            const showView = (view) => { /* ... (same as before) ... */ };
            const showMessageModal = (title, message) => { /* ... (same as before) ... */ };
            const formatBytes = (bytes, decimals = 2) => { /* ... (same as before) ... */ };
            const updateStorageUsage = async () => { /* ... (same as before) ... */ };
            const renderFolders = () => { /* ... (same as before) ... */ };
            const renderRecords = (recordsToRender, parentElement) => { /* ... (same as before) ... */ };
            const selectRecord = (recordId) => { /* ... (same as before) ... */ };
            const deselectAll = (renderHome = true) => { /* ... (same as before) ... */ };
            const renderPromptTemplates = () => { /* ... (same as before) ... */ };
            
            // --- Speech Recognition & Audio Recording ---
            const setupRecognition = () => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) { showMessageModal('エラー', 'Web Speech APIに対応していません。'); return; }
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP'; recognition.continuous = true; recognition.interimResults = true;
                recognition.onstart = () => {
                    recordButton.textContent = '録音を停止'; recordButton.classList.replace('bg-blue-600', 'bg-red-600');
                    deselectAll(); contentTitle.textContent = 'リアルタイム文字起こし';
                    transcriptContainer.innerHTML = ''; showView('transcript');
                };
                recognition.onend = () => { if (isRecording) { console.log("Speech recognition stopped, restarting..."); recognition.start(); } };

                recognition.onresult = (event) => {
                    console.log(event); // For debugging Android issues
                    let interimTranscript = '';
                    let finalTranscript = '';
                    for (let i = 0; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript + ' ';
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    currentTranscript = finalTranscript;
                    transcriptContainer.innerHTML = `<p>${finalTranscript}<span class="text-gray-400">${interimTranscript}</span></p>`;
                };
                
                recognition.onerror = (event) => { showMessageModal('エラー', `音声認識エラー: ${event.error}`); if(isRecording) stopRecording(false); };
            };
            
            const startRecording = async () => {
                if (isRecording) return;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    isRecording = true; audioChunks = []; mediaRecorder = new MediaRecorder(localStream);
                    mediaRecorder.addEventListener("dataavailable", e => audioChunks.push(e.data)); mediaRecorder.start();
                    currentTranscript = ''; 
                    recognition.start();
                    timerDisplay.classList.remove('hidden');
                    recordingStartTime = Date.now();
                    recordingTimerInterval = setInterval(() => {
                        const elapsedTime = Date.now() - recordingStartTime;
                        const seconds = Math.floor((elapsedTime / 1000) % 60).toString().padStart(2, '0');
                        const minutes = Math.floor((elapsedTime / (1000 * 60)) % 60).toString().padStart(2, '0');
                        const hours = Math.floor(elapsedTime / (1000 * 60 * 60)).toString().padStart(2, '0');
                        timerDisplay.textContent = `${hours}:${minutes}:${seconds}`;
                    }, 1000);
                } catch (err) { showMessageModal('マイクエラー', 'マイクへのアクセスが許可されませんでした。'); }
            };

            const stopRecording = (saveText = true) => {
                if (!isRecording) return;
                isRecording = false; recognition.stop();
                
                clearInterval(recordingTimerInterval);
                timerDisplay.classList.add('hidden');
                timerDisplay.textContent = '00:00:00';
                const handleStop = async () => {
                    if(localStream) localStream.getTracks().forEach(track => track.stop());
                    recordButton.textContent = '録音を開始'; recordButton.classList.replace('bg-red-600', 'bg-blue-600');
                    if (saveText && currentTranscript.trim()) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const newRecord = { id: crypto.randomUUID(), title: recordTitleInput.value.trim() || '無題の記録', date: new Date().toISOString(), transcript: currentTranscript.trim(), summary: null, folderId: null, audioBlob: audioBlob };
                        await saveData('records', newRecord); records.unshift(newRecord);
                        showMessageModal('録音完了', `「${newRecord.title}」を保存しました。`); deselectAll(); await updateStorageUsage();
                    } else { deselectAll(); }
                };
                if(mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.onstop = handleStop; mediaRecorder.stop(); } else { handleStop(); }
            };

            const transcribeFile = async (file) => { /* ... (same as before) ... */ };
            const executeSummary = async (template) => { /* ... (same as before) ... */ };
            const showContextMenu = (e, id, type) => { /* ... (same as before) ... */ };
            
            // --- Attach Event Listeners ---
            const attachAllEventListeners = () => {
                homeButton.addEventListener('click', deselectAll);
                recordButton.addEventListener('click', () => { if (isRecording) { stopRecording(); } else { titleModal.classList.remove('hidden'); titleModal.classList.add('flex'); recordTitleInput.value = `記録 - ${new Date().toLocaleString('ja-JP')}`; } });
                startRecordingButton.addEventListener('click', () => { titleModal.classList.add('hidden'); startRecording(); });
                cancelRecordingButton.addEventListener('click', () => titleModal.classList.add('hidden'));
                summarizeButton.addEventListener('click', () => {
                    if (!selectedRecord || !geminiApiKey) { showMessageModal('APIキー未設定', '設定画面でGemini APIキーを入力してください。'); return; }
                    contentTitle.textContent = '要約プロンプトを選択';
                    summaryContainer.innerHTML = ''; showView('summary');
                    promptTemplates.forEach(template => {
                        const button = document.createElement('button');
                        button.className = 'w-full text-left p-3 bg-gray-600 rounded-lg hover:bg-gray-500 mb-2';
                        button.innerHTML = `<div class="font-bold">${template.title}</div><p class="text-sm text-gray-400 truncate">${template.text}</p>`;
                        button.addEventListener('click', () => executeSummary(template));
                        summaryContainer.appendChild(button);
                    });
                });
                audioUpload.addEventListener('change', (e) => transcribeFile(e.target.files[0]));
                settingsButton.addEventListener('click', () => settingsModal.classList.replace('hidden', 'flex'));
                closeSettingsButton.addEventListener('click', async () => {
                    settingsModal.classList.replace('flex', 'hidden');
                    geminiApiKey = geminiApiKeyInput.value;
                    huggingFaceApiKey = huggingFaceApiKeyInput.value;
                    await saveData('settings', {key: 'geminiApiKey', value: geminiApiKey});
                    await saveData('settings', {key: 'huggingFaceApiKey', value: huggingFaceApiKey});
                });
                closeModalButton.addEventListener('click', () => messageModal.classList.add('hidden'));
                addFolderButton.addEventListener('click', async () => {
                    const name = prompt('新しいフォルダ名:');
                    if (name && name.trim()) { const newFolder = { id: crypto.randomUUID(), name: name.trim() }; await saveData('folders', newFolder); folders.push(newFolder); renderFolders(); }
                });
                clearDataButton.addEventListener('click', () => { if (confirm('全ての記録、フォルダ、設定を削除します。よろしいですか？')) resetData(); });
                addTemplateButton.addEventListener('click', async () => {
                    const title = prompt('新しいテンプレートのタイトル:');
                    if(!title) return;
                    const text = prompt('新しいプロンプトの内容:');
                    if(!text) return;
                    promptTemplates.push({title, text});
                    await saveData('settings', {key: 'promptTemplates', value: promptTemplates});
                    renderPromptTemplates();
                });
                document.addEventListener('click', () => contextMenu.classList.add('hidden'));
                contextRename.addEventListener('click', async () => {
                    const id = contextMenu.dataset.id; const type = contextMenu.dataset.type; contextMenu.classList.add('hidden');
                    if (type === 'folder') {
                        const folder = folders.find(f => f.id === id);
                        if (folder) { const newName = prompt('新しいフォルダ名:', folder.name); if (newName && newName.trim()) { folder.name = newName.trim(); await saveData('folders', folder); renderFolders(); } }
                    } else if (type === 'record') {
                        const record = records.find(r => r.id === id);
                        if (record) { const newTitle = prompt('新しい記録タイトル:', record.title); if (newTitle && newTitle.trim()) { record.title = newTitle.trim(); await saveData('records', record); if(selectedRecord && selectedRecord.id === id) contentTitle.textContent = `記録: ${record.title}`; deselectAll(); } }
                    }
                });
                contextDelete.addEventListener('click', () => {
                    const id = contextMenu.dataset.id; const type = contextMenu.dataset.type; contextMenu.classList.add('hidden');
                    deleteConfirmModal.classList.remove('hidden'); deleteConfirmModal.classList.add('flex');
                    if (type === 'folder') {
                        const folder = folders.find(f => f.id === id);
                        if (folder) {
                            if(records.some(r => r.folderId === id)) { showMessageModal('削除不可', 'フォルダ内に記録があるため削除できません。'); deleteConfirmModal.classList.add('hidden'); return; }
                            deleteConfirmMessage.textContent = `フォルダ「${folder.name}」を削除しますか？`;
                            confirmDeleteButton.onclick = async () => { await deleteData('folders', id); folders = folders.filter(f => f.id !== id); renderFolders(); deleteConfirmModal.classList.add('hidden'); deselectAll(); };
                        }
                    } else if (type === 'record') {
                        const record = records.find(r => r.id === id);
                        if (record) {
                            deleteConfirmMessage.textContent = `記録「${record.title}」を削除しますか？\n(音声ファイルも一緒に削除されます)`;
                            confirmDeleteButton.onclick = async () => { await deleteData('records', id); records = records.filter(r => r.id !== id); deleteConfirmModal.classList.add('hidden'); showMessageModal('削除完了', `記録「${record.title}」を削除しました。`); deselectAll(); await updateStorageUsage(); };
                        }
                    }
                });
                contextDeleteAudio.addEventListener('click', async () => {
                    const id = contextMenu.dataset.id; contextMenu.classList.add('hidden');
                    const record = records.find(r => r.id === id);
                    if (record && confirm(`「${record.title}」の音声ファイルのみを削除しますか？\n文字起こしテキストは残ります。`)) {
                        delete record.audioBlob;
                        await saveData('records', record);
                        showMessageModal('削除完了', '音声ファイルを削除しました。');
                        if (selectedRecord && selectedRecord.id === id) selectRecord(id); else deselectAll();
                        await updateStorageUsage();
                    }
                });
                cancelDeleteButton.addEventListener('click', () => { deleteConfirmModal.classList.add('hidden'); deleteConfirmModal.classList.remove('flex'); });
            };
            
            // Re-assign all functions to the global scope to prevent them from being garbage collected
            Object.assign(window, {
                initDB, saveData, getAllData, deleteData, initializeApp, migrateFromLocalStorage, renderUI,
                loadDataFromDB, setupDefaultTemplates, resetData, showView, showMessageModal, formatBytes,
                updateStorageUsage, renderFolders, renderRecords, selectRecord, deselectAll, renderPromptTemplates,
                setupRecognition, startRecording, stopRecording, transcribeFile, executeSummary, showContextMenu,
                attachAllEventListeners
            });

            initializeApp();
        });
    </script>
</body>
</html>

