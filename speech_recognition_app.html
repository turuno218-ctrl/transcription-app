<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音声文字起こしアプリ V1.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body { font-family: 'Inter', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .main-content { flex-grow: 1; }
        .right-panel { width: 25rem; }
        .text-area { min-height: 200px; height: 100%; resize: none; }
        .record-item.selected { border: 2px solid #3b82f6; }
        .dragging { opacity: 0.5; }
        .drag-over { border: 2px dashed #3b82f6; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen overflow-hidden">
    <!-- メインレイアウト -->
    <div class="flex flex-grow overflow-hidden">
        <!-- 左パネル：履歴 -->
        <div id="left-panel" class="w-1/4 bg-gray-800 p-4 flex flex-col h-full overflow-y-auto">
            <h2 class="text-xl font-bold mb-4">記録履歴</h2>
            <div class="flex mb-4">
                <button id="new-folder-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full">新しいフォルダを作成</button>
            </div>
            <div id="records-list" class="flex-grow"></div>
            <div id="storage-usage" class="mt-4 text-sm text-gray-400"></div>
        </div>
        <!-- 中央パネル：文字起こしエリア -->
        <div id="center-panel" class="main-content bg-gray-900 p-6 flex flex-col h-full">
            <div id="main-controls" class="flex items-center justify-between mb-4">
                 <h1 class="text-2xl font-bold">リアルタイム文字起こし</h1>
                 <div id="timer" class="text-2xl font-mono bg-gray-800 px-4 py-2 rounded">00:00:00</div>
            </div>
            <div class="flex space-x-4 mb-4">
                <button id="start-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-full transition duration-300 ease-in-out transform hover:scale-105">録音開始</button>
                <button id="stop-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full hidden transition duration-300 ease-in-out transform hover:scale-105">録音停止</button>
            </div>
             <textarea id="transcript" class="w-full flex-grow bg-gray-800 p-4 rounded text-lg leading-relaxed border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="ここに文字起こし結果が表示されます..."></textarea>
            <div class="mt-4 flex space-x-4">
                <button id="save-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full" disabled>記録を保存</button>
                <input type="file" id="file-input" class="hidden" accept="audio/*">
                <button id="file-transcribe-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded w-full">ファイルから文字起こし</button>
            </div>
        </div>
        <!-- 右パネル：詳細・再生 -->
        <div id="right-panel" class="right-panel bg-gray-800 p-6 flex-col h-full overflow-y-auto hidden">
             <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">詳細</h2>
                <button id="close-right-panel" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="record-details">
                <h3 id="record-title" class="text-lg font-semibold mb-2"></h3>
                <p id="record-date" class="text-sm text-gray-400 mb-4"></p>
                <audio id="audio-player" controls class="w-full mb-4"></audio>
                <textarea id="record-text" class="w-full h-64 bg-gray-700 p-2 rounded"></textarea>
                 <div class="mt-4 flex space-x-2">
                     <button id="summarize-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded w-full">要約を開始</button>
                     <button id="update-record-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">変更を保存</button>
                 </div>
            </div>
             <div id="summary-display" class="hidden mt-6">
                <h3 class="text-lg font-semibold mb-2">要約結果</h3>
                <div id="summary-result" class="w-full bg-gray-700 p-3 rounded whitespace-pre-wrap"></div>
            </div>
        </div>
    </div>

    <!-- 各種モーダル -->
    <!-- ローディングモーダル -->
    <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-white mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p id="loading-message" class="text-lg">処理中です。しばらくお待ちください...</p>
        </div>
    </div>
    <!-- 要約プロンプト選択モーダル -->
    <div id="prompt-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl w-1/2">
            <h2 class="text-xl font-bold mb-6">要約プロンプトを選択してください</h2>
            <select id="prompt-select" class="w-full p-3 bg-gray-700 rounded mb-6"></select>
            <div class="flex justify-end space-x-4">
                <button id="cancel-summary" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">キャンセル</button>
                <button id="confirm-summary" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">要約を実行</button>
            </div>
        </div>
    </div>
    <!-- メッセージ表示モーダル -->
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center">
            <h3 id="message-title" class="text-lg font-bold mb-4"></h3>
            <p id="message-body" class="mb-6"></p>
            <button id="message-close-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded">閉じる</button>
        </div>
    </div>

    <!-- 右クリックコンテキストメニュー -->
    <div id="context-menu" class="hidden absolute bg-gray-700 rounded-md shadow-lg py-1 z-50">
        <a href="#" id="context-rename" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">名前を変更</a>
        <a href="#" id="context-delete-audio" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">音声ファイルのみ削除</a>
        <a href="#" id="context-delete" class="block px-4 py-2 text-sm text-red-400 hover:bg-red-500 hover:text-white">削除</a>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM要素の取得
            const startButton = document.getElementById('start-button');
            const stopButton = document.getElementById('stop-button');
            const saveButton = document.getElementById('save-button');
            const transcriptArea = document.getElementById('transcript');
            const recordsList = document.getElementById('records-list');
            const rightPanel = document.getElementById('right-panel');
            const closeRightPanel = document.getElementById('close-right-panel');
            const audioPlayer = document.getElementById('audio-player');
            const recordTitle = document.getElementById('record-title');
            const recordDate = document.getElementById('record-date');
            const recordText = document.getElementById('record-text');
            const updateRecordButton = document.getElementById('update-record-button');
            const newFolderButton = document.getElementById('new-folder-button');
            const fileTranscribeButton = document.getElementById('file-transcribe-button');
            const fileInput = document.getElementById('file-input');
            const loadingModal = document.getElementById('loading-modal');
            const loadingMessage = document.getElementById('loading-message');
            const storageUsage = document.getElementById('storage-usage');
            const timerDisplay = document.getElementById('timer');
            const summarizeButton = document.getElementById('summarize-button');
            const promptModal = document.getElementById('prompt-modal');
            const promptSelect = document.getElementById('prompt-select');
            const cancelSummary = document.getElementById('cancel-summary');
            const confirmSummary = document.getElementById('confirm-summary');
            const summaryDisplay = document.getElementById('summary-display');
            const summaryResult = document.getElementById('summary-result');
            const messageModal = document.getElementById('message-modal');
            const messageTitle = document.getElementById('message-title');
            const messageBody = document.getElementById('message-body');
            const messageCloseButton = document.getElementById('message-close-button');
            const contextMenu = document.getElementById('context-menu');
            const contextRename = document.getElementById('context-rename');
            const contextDeleteAudio = document.getElementById('context-delete-audio');
            const contextDelete = document.getElementById('context-delete');
            
            // 音声認識関連の変数
            let recognition;
            let isRecording = false;
            let finalTranscript = '';
            let audioChunks = [];
            let mediaRecorder;
            let audioBlob;
            
            // タイマー関連
            let timerInterval;
            let seconds = 0;

            // =================================================================================
            // Androidでの録音安定性向上のための監視タイマー (Watchdog Timer)
            // =================================================================================
            let recognitionWatchdogInterval;
            // この変数は、音声認識が実際にアクティブかどうかを追跡します。
            // Web Speech APIの `onstart` と `onend` / `onerror` イベントで更新されます。
            let isRecognitionActuallyRunning = false;
            
            const startRecognitionWatchdog = () => {
                // 既に監視中なら何もしない
                if (recognitionWatchdogInterval) return;

                // 2秒ごとに音声認識の状態をチェックするタイマーを開始
                recognitionWatchdogInterval = setInterval(() => {
                    // isRecordingはユーザーが「録音中」と期待している状態
                    // isRecognitionActuallyRunningはAPIが実際に動いている状態
                    // ユーザーは録音中と思っているのに、APIが動いていなければ...
                    if (isRecording && !isRecognitionActuallyRunning) {
                        console.warn('Watchdog detected recognition stall. Restarting...');
                        // 認識を再起動
                        try {
                            recognition.start();
                        } catch(e) {
                            console.error("Watchdog failed to restart recognition:", e);
                        }
                    }
                }, 2000); // 2秒ごとにチェック
                 console.log("Recognition watchdog started.");
            };

            const stopRecognitionWatchdog = () => {
                if (recognitionWatchdogInterval) {
                    clearInterval(recognitionWatchdogInterval);
                    recognitionWatchdogInterval = null;
                     console.log("Recognition watchdog stopped.");
                }
            };
            // =================================================================================

            // データ管理
            let db;
            let records = [];
            let folders = [];
            let selectedRecord = null;
            
            // 要約プロンプト
            const prompts = {
                "simple_summary": { name: "シンプル要約", content: "以下の文章を簡潔に要約してください。:\n\n{text}" },
                "meeting_minutes": { name: "議事録作成", content: "以下の会議の文字起こしテキストから、主要な決定事項、アクションアイテム、発言者ごとの要点をまとめた議事録を作成してください。:\n\n{text}" },
                "action_items": { name: "ToDo抽出", content: "以下のテキストから、発生したタスクやToDo（やるべきこと）をリスト形式で抽出してください。:\n\n{text}" }
            };

            // Web Speech APIの初期化
            const initializeSpeechRecognition = () => {
                window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!window.SpeechRecognition) {
                    showMessageModal('エラー', 'お使いのブラウザは音声認識に対応していません。');
                    startButton.disabled = true;
                    return;
                }
                recognition = new SpeechRecognition();
                recognition.lang = 'ja-JP';
                recognition.interimResults = true;
                recognition.continuous = false; // onendを頻繁に発生させるためにfalseに設定

                recognition.onstart = () => {
                    isRecognitionActuallyRunning = true; // 認識が開始された
                    console.log('Recognition started.');
                };

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    transcriptArea.value = finalTranscript + interimTranscript;
                    saveButton.disabled = finalTranscript.trim().length === 0;
                };

                recognition.onerror = (event) => {
                    isRecognitionActuallyRunning = false; // 認識がエラーで停止
                    console.error('Speech recognition error:', event.error);
                };

                recognition.onend = () => {
                    isRecognitionActuallyRunning = false; // 認識が正常に終了
                    console.log('Recognition ended.');
                    if (isRecording) { // ユーザーがまだ録音停止を押していない場合
                        try {
                           recognition.start(); // 録音を継続
                        } catch(e) {
                           console.error("Failed to restart recognition on 'onend':", e);
                        }
                    }
                };
            };
            
            // データベース初期化
            const initializeDB = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('TranscriptionAppDB', 2);
                    request.onupgradeneeded = (event) => {
                        db = event.target.result;
                        if (!db.objectStoreNames.contains('records')) {
                            db.createObjectStore('records', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('folders')) {
                           db.createObjectStore('folders', { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => {
                        db = event.target.result;
                        resolve();
                    };
                    request.onerror = (event) => {
                        console.error('Database error:', event.target.errorCode);
                        reject();
                    };
                });
            };

            // データ保存・読み込み
            const saveData = (storeName, data) => {
                 return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Failed to save data to ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                 });
            };

            const loadAllData = (storeName) => {
                return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => {
                        console.error(`Failed to load data from ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            };
            
            const deleteData = (storeName, id) => {
                return new Promise((resolve, reject) => {
                    if (!db) { reject("DB not initialized"); return; }
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error(`Failed to delete data from ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                });
            };

            // UI更新
            const renderRecordsList = () => {
                recordsList.innerHTML = '';
                const topLevelRecords = records.filter(r => !r.folderId);
                
                folders.forEach(folder => {
                    const folderEl = createFolderElement(folder);
                    recordsList.appendChild(folderEl);
                });
                topLevelRecords.forEach(record => {
                    const recordEl = createRecordElement(record);
                    recordsList.appendChild(recordEl);
                });
                updateStorageUsage();
            };

            // フォルダ・記録要素の作成
            const createFolderElement = (folder) => {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'mb-2';
                folderDiv.dataset.id = folder.id;
                folderDiv.dataset.type = 'folder';

                const folderHeader = document.createElement('div');
                folderHeader.className = 'bg-gray-700 p-2 rounded cursor-pointer flex justify-between items-center';
                folderHeader.textContent = `📁 ${folder.name}`;
                folderHeader.draggable = true;
                
                folderDiv.appendChild(folderHeader);

                const recordsInFolderDiv = document.createElement('div');
                recordsInFolderDiv.className = 'ml-4 mt-1' + (folder.isOpen ? '' : ' hidden');
                const recordsInFolder = records.filter(r => r.folderId === folder.id);
                recordsInFolder.forEach(record => {
                    recordsInFolderDiv.appendChild(createRecordElement(record));
                });
                folderDiv.appendChild(recordsInFolderDiv);
                
                // イベントリスナー
                folderHeader.addEventListener('click', () => toggleFolder(folder.id));
                folderHeader.addEventListener('contextmenu', (e) => showContextMenu(e, folder.id, 'folder'));
                addDragDropListeners(folderHeader, folder.id, 'folder');

                return folderDiv;
            };

            const createRecordElement = (record) => {
                const div = document.createElement('div');
                div.className = 'record-item bg-gray-700 p-3 mb-2 rounded cursor-pointer border-2 border-transparent';
                div.textContent = record.title;
                div.dataset.id = record.id;
                div.dataset.type = 'record';
                div.draggable = true;

                if (selectedRecord && selectedRecord.id === record.id) {
                    div.classList.add('selected');
                }
                
                // イベントリスナー
                div.addEventListener('click', () => selectRecord(record.id));
                div.addEventListener('contextmenu', (e) => showContextMenu(e, record.id, 'record'));
                addDragDropListeners(div, record.id, 'record');

                return div;
            };

            // 録音処理
            const startRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.onstop = () => {
                        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        audioChunks = [];
                    };
                    mediaRecorder.start();
                    recognition.start();
                    startRecognitionWatchdog(); // 監視を開始
                    isRecording = true;
                    finalTranscript = '';
                    transcriptArea.value = '';
                    startButton.classList.add('hidden');
                    stopButton.classList.remove('hidden');
                    saveButton.disabled = true;
                    startTimer();
                } catch (err) {
                    console.error('Error starting recording:', err);
                    showMessageModal('マイクエラー', 'マイクへのアクセスが拒否されたか、マイクが利用できません。');
                }
            };

            const stopRecording = () => {
                if (isRecording) {
                    isRecording = false; // onendでの再開を止める
                    mediaRecorder.stop();
                    recognition.stop();
                    stopRecognitionWatchdog(); // 監視を停止
                    stopButton.classList.add('hidden');
                    startButton.classList.remove('hidden');
                    saveButton.disabled = finalTranscript.trim().length === 0;
                    stopTimer();
                }
            };
            
            // タイマー処理
            const startTimer = () => {
                seconds = 0;
                timerDisplay.textContent = '00:00:00';
                timerInterval = setInterval(() => {
                    seconds++;
                    const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
                    const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
                    const s = String(seconds % 60).padStart(2, '0');
                    timerDisplay.textContent = `${h}:${m}:${s}`;
                }, 1000);
            };

            const stopTimer = () => {
                clearInterval(timerInterval);
            };

            // 記録選択・表示
            const selectRecord = (id) => {
                selectedRecord = records.find(r => r.id === id);
                if (selectedRecord) {
                    document.querySelectorAll('.record-item').forEach(el => {
                        el.classList.toggle('selected', el.dataset.id === id);
                    });
                    
                    recordTitle.textContent = selectedRecord.title;
                    recordDate.textContent = new Date(selectedRecord.timestamp).toLocaleString();
                    recordText.value = selectedRecord.transcript;

                    if (selectedRecord.audioBlob) {
                        const audioUrl = URL.createObjectURL(selectedRecord.audioBlob);
                        audioPlayer.src = audioUrl;
                        audioPlayer.style.display = 'block';
                    } else {
                        audioPlayer.style.display = 'none';
                    }
                    rightPanel.classList.remove('hidden');
                    rightPanel.classList.add('flex');
                    summaryDisplay.classList.add('hidden');
                }
            };

            const deselectAll = () => {
                selectedRecord = null;
                document.querySelectorAll('.record-item.selected').forEach(el => el.classList.remove('selected'));
                rightPanel.classList.add('hidden');
                rightPanel.classList.remove('flex');
            };

            // データマイグレーション
            const migrateFromLocalStorage = async () => {
                const oldRecords = localStorage.getItem('transcripts');
                if (oldRecords) {
                    const parsedRecords = JSON.parse(oldRecords);
                    if (Array.isArray(parsedRecords) && parsedRecords.length > 0) {
                        const needsMigration = await loadAllData('records').then(data => data.length === 0);
                        if(needsMigration) {
                           if(confirm("以前のバージョンのデータが見つかりました。新しいデータベースにデータを移行しますか？（この操作は一度だけ行われます）")) {
                               for (const record of parsedRecords) {
                                   await saveData('records', {
                                       id: record.id || `migrated-${Date.now()}-${Math.random()}`,
                                       title: record.title || `無題の記録 ${new Date(record.timestamp).toLocaleDateString()}`,
                                       transcript: record.transcript,
                                       timestamp: record.timestamp,
                                       audioBlob: null // 古いデータには音声がない
                                   });
                               }
                               localStorage.removeItem('transcripts'); // 移行後に古いデータを削除
                               showMessageModal('移行完了', 'データの移行が完了しました。');
                           }
                        }
                    }
                }
            };
            
            // ストレージ使用量計算
            const updateStorageUsage = async () => {
                if (navigator.storage && navigator.storage.estimate) {
                    const estimate = await navigator.storage.estimate();
                    const usageMb = (estimate.usage / 1024 / 1024).toFixed(2);
                    const quotaMb = (estimate.quota / 1024 / 1024).toFixed(2);
                    storageUsage.textContent = `ストレージ使用量: ${usageMb} MB / ${quotaMb} MB`;
                }
            };
            
            // イベントリスナー設定
            const setupEventListeners = () => {
                startButton.addEventListener('click', startRecording);
                stopButton.addEventListener('click', stopRecording);
                
                saveButton.addEventListener('click', async () => {
                    const title = prompt('記録のタイトルを入力してください:', `録音 ${new Date().toLocaleString()}`);
                    if (title) {
                        const newRecord = {
                            id: `record-${Date.now()}`,
                            title: title,
                            transcript: finalTranscript,
                            timestamp: Date.now(),
                            audioBlob: audioBlob
                        };
                        await saveData('records', newRecord);
                        records.push(newRecord);
                        renderRecordsList();
                        transcriptArea.value = '';
                        finalTranscript = '';
                        saveButton.disabled = true;
                        showMessageModal('保存完了', `「${title}」を保存しました。`);
                    }
                });

                updateRecordButton.addEventListener('click', async () => {
                    if (selectedRecord) {
                        selectedRecord.transcript = recordText.value;
                        await saveData('records', selectedRecord);
                        showMessageModal('更新完了', `「${selectedRecord.title}」を更新しました。`);
                    }
                });
                
                closeRightPanel.addEventListener('click', deselectAll);
                
                newFolderButton.addEventListener('click', async () => {
                    const name = prompt("新しいフォルダ名を入力してください:");
                    if (name) {
                        const newFolder = { id: `folder-${Date.now()}`, name: name, isOpen: true };
                        await saveData('folders', newFolder);
                        folders.push(newFolder);
                        renderRecordsList();
                    }
                });

                fileTranscribeButton.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', handleFileUpload);
                
                summarizeButton.addEventListener('click', () => {
                    promptSelect.innerHTML = '';
                    Object.entries(prompts).forEach(([key, value]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = value.name;
                        promptSelect.appendChild(option);
                    });
                    promptModal.classList.remove('hidden');
                    promptModal.classList.add('flex');
                });
                cancelSummary.addEventListener('click', () => {
                    promptModal.classList.add('hidden');
                    promptModal.classList.remove('flex');
                });
                confirmSummary.addEventListener('click', handleSummary);
                
                messageCloseButton.addEventListener('click', () => {
                    messageModal.classList.add('hidden');
                    messageModal.classList.remove('flex');
                });
                
                 // コンテキストメニュー関連
                document.addEventListener('click', () => contextMenu.classList.add('hidden'));
                contextMenu.addEventListener('click', e => e.stopPropagation());
                
                contextRename.addEventListener('click', handleRename);
                contextDelete.addEventListener('click', handleDelete);
                contextDeleteAudio.addEventListener('click', handleDeleteAudio);
            };

            // その他の関数 (フォルダ操作、ドラッグ＆ドロップ、ファイル処理など)
            const toggleFolder = async (id) => {
                const folder = folders.find(f => f.id === id);
                if (folder) {
                    folder.isOpen = !folder.isOpen;
                    await saveData('folders', folder);
                    renderRecordsList();
                }
            };

            const showContextMenu = (e, id, type) => {
                e.preventDefault();
                e.stopPropagation();
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.classList.remove('hidden');
                contextMenu.dataset.id = id;
                contextMenu.dataset.type = type;
                contextDeleteAudio.style.display = (type === 'record') ? 'block' : 'none';
            };
            
            const handleRename = async () => {
                const id = contextMenu.dataset.id;
                const type = contextMenu.dataset.type;
                contextMenu.classList.add('hidden');
                if(type === 'record') {
                    const record = records.find(r => r.id === id);
                    if(record){
                        const newName = prompt("新しい記録名を入力してください:", record.title);
                        if (newName) {
                            record.title = newName;
                            await saveData('records', record);
                            if(selectedRecord && selectedRecord.id === id) recordTitle.textContent = newName;
                        }
                    }
                } else if (type === 'folder') {
                    const folder = folders.find(f => f.id === id);
                    if(folder) {
                        const newName = prompt("新しいフォルダ名を入力してください:", folder.name);
                        if (newName) {
                            folder.name = newName;
                            await saveData('folders', folder);
                        }
                    }
                }
                renderRecordsList();
            };

            const handleDelete = async () => {
                const id = contextMenu.dataset.id;
                const type = contextMenu.dataset.type;
                contextMenu.classList.add('hidden');

                if (type === 'record') {
                    const record = records.find(r => r.id === id);
                    if (record && confirm(`記録「${record.title}」を完全に削除しますか？`)) {
                        await deleteData('records', id);
                        records = records.filter(r => r.id !== id);
                        if (selectedRecord && selectedRecord.id === id) deselectAll();
                    }
                } else if (type === 'folder') {
                    const folder = folders.find(f => f.id === id);
                    const recordsInFolder = records.filter(r => r.folderId === id);
                    if (folder && confirm(`フォルダ「${folder.name}」を削除しますか？\n中の${recordsInFolder.length}個の記録も全て削除されます。`)) {
                        for(const record of recordsInFolder) {
                            await deleteData('records', record.id);
                        }
                        await deleteData('folders', id);
                        records = records.filter(r => r.folderId !== id);
                        folders = folders.filter(f => f.id !== id);
                    }
                }
                renderRecordsList();
            };
            
            const handleDeleteAudio = async () => {
                 const id = contextMenu.dataset.id;
                 contextMenu.classList.add('hidden');
                 const record = records.find(r => r.id === id);
                 if (record && confirm(`「${record.title}」の音声ファイルのみを削除しますか？テキストは残ります。`)) {
                     delete record.audioBlob;
                     await saveData('records', record);
                     showMessageModal('削除完了', '音声ファイルを削除しました。');
                     if (selectedRecord && selectedRecord.id === id) selectRecord(id);
                     await updateStorageUsage();
                 }
            };
            
            const addDragDropListeners = (element, id, type) => {
                element.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    e.dataTransfer.setData('text/plain', JSON.stringify({id, type}));
                    element.classList.add('dragging');
                });
                element.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    element.classList.remove('dragging');
                });
                 element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (type === 'folder' || !e.currentTarget.dataset.id) { // フォルダまたはリストのルート
                        e.stopPropagation();
                        element.classList.add('drag-over');
                    }
                });
                element.addEventListener('dragleave', (e) => {
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                });
                element.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                    const droppedData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    if (droppedData.type === 'record') {
                        const record = records.find(r => r.id === droppedData.id);
                        if(record) {
                            if (type === 'folder') { // フォルダにドロップ
                                record.folderId = id;
                            }
                             await saveData('records', record);
                             renderRecordsList();
                        }
                    }
                });
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const apiKey = prompt("Hugging Face APIキーを入力してください:");
                if (!apiKey) return;
                
                loadingMessage.textContent = "音声ファイルをアップロード中...";
                loadingModal.classList.remove('hidden');

                try {
                    const response = await fetch("https://api-inference.huggingface.co/models/openai/whisper-large-v3", {
                        headers: { Authorization: `Bearer ${apiKey}` },
                        method: "POST",
                        body: file,
                    });
                    const result = await response.json();
                    
                    if(result.text) {
                        const newRecord = {
                            id: `record-${Date.now()}`,
                            title: file.name,
                            transcript: result.text,
                            timestamp: Date.now(),
                            audioBlob: new Blob([file], {type: file.type})
                        };
                        await saveData('records', newRecord);
                        records.push(newRecord);
                        renderRecordsList();
                        selectRecord(newRecord.id);
                    } else {
                        throw new Error(result.error || "APIからの応答が不正です。");
                    }
                } catch (error) {
                    console.error('File transcription error:', error);
                    showMessageModal('APIエラー', `文字起こしに失敗しました: ${error.message}`);
                } finally {
                    loadingModal.classList.add('hidden');
                    fileInput.value = ''; // 同じファイルを選択できるようにリセット
                }
            };
            
            const handleSummary = async () => {
                const apiKey = prompt("Gemini APIキーを入力してください:");
                if (!apiKey || !selectedRecord) return;
                
                promptModal.classList.add('hidden');
                loadingMessage.textContent = "要約を生成中です...";
                loadingModal.classList.remove('hidden');
                
                try {
                    const selectedPromptKey = promptSelect.value;
                    const promptTemplate = prompts[selectedPromptKey].content;
                    const fullPrompt = promptTemplate.replace('{text}', selectedRecord.transcript);

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    
                    if(!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`APIリクエスト失敗: ${errorBody.error.message}`);
                    }

                    const result = await response.json();
                    const summary = result.candidates[0].content.parts[0].text;
                    
                    summaryResult.textContent = summary;
                    summaryDisplay.classList.remove('hidden');
                    
                    // 中央パネルを要約結果表示モードに切り替える
                    document.getElementById('main-controls').classList.add('hidden');
                    document.getElementById('transcript').parentElement.classList.add('hidden'); // textareaとボタンを含むdiv
                    document.getElementById('center-panel').insertAdjacentElement('afterbegin', summaryDisplay);

                } catch (error) {
                    console.error('Summary generation error:', error);
                    showMessageModal('APIエラー', `要約の生成に失敗しました: ${error.message}`);
                } finally {
                    loadingModal.classList.add('hidden');
                }
            };
            
            const showMessageModal = (title, body) => {
                 messageTitle.textContent = title;
                 messageBody.textContent = body;
                 messageModal.classList.remove('hidden');
                 messageModal.classList.add('flex');
            };

            // アプリケーション初期化
            const initializeApp = async () => {
                initializeSpeechRecognition();
                await initializeDB();
                await migrateFromLocalStorage();
                [records, folders] = await Promise.all([loadAllData('records'), loadAllData('folders')]);
                renderRecordsList();
                setupEventListeners();
                updateStorageUsage();
            };
            
            initializeApp();
        });
    </script>
</body>
</html>
